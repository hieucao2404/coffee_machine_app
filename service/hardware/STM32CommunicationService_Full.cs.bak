using System.IO.Ports;
using System.Text.Json;
using Microsoft.Extensions.Logging;

namespace CoffeeMachine.service.Hardware;

public class STM32CommunicationService : ISTM32CommunicationService
{
    private readonly ILogger<STM32CommunicationService> _logger;
    private SerialPort? _serialPort;

    public STM32CommunicationService(ILogger<STM32CommunicationService> logger)
    {
        _logger = logger;
    }

    public bool IsConnected => _serialPort?.IsOpen ?? false;

    /// <summary>
    /// Auto-detect and connect to STM32
    /// </summary>
    public async Task<bool> ConnectAsync(string portName = "", int baudRate = 115200)
    {
        try
        {
            string selectedPort = portName;

            // Auto-detect port if not specified
            if (string.IsNullOrEmpty(portName))
            {
                _logger.LogInformation("üîç Auto-detecting STM32 port...");
                selectedPort = await DetectSTM32PortAsync(baudRate);
                
                if (string.IsNullOrEmpty(selectedPort))
                {
                    _logger.LogWarning("‚ùå No STM32 device found");
                    return false;
                }
            }

            _serialPort = new SerialPort(selectedPort, baudRate)
            {
                Parity = Parity.None,
                StopBits = StopBits.One,
                DataBits = 8,
                Handshake = Handshake.None,
                ReadTimeout = 5000,
                WriteTimeout = 5000
            };

            _serialPort.Open();
            _logger.LogInformation($"‚úì Connected to STM32 on {selectedPort} at {baudRate} baud");
            
            await Task.Delay(100); // Give STM32 time to initialize
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to connect to STM32");
            return false;
        }
    }

    /// <summary>
    /// Detect STM32 port automatically by probing available ports
    /// </summary>
    private async Task<string> DetectSTM32PortAsync(int baudRate)
    {
        var availablePorts = SerialPort.GetPortNames();
        
        if (availablePorts.Length == 0)
        {
            _logger.LogWarning("No serial ports found on this system");
            return string.Empty;
        }

        _logger.LogInformation($"Found {availablePorts.Length} serial port(s): {string.Join(", ", availablePorts)}");

        // Priority order for port detection (common STM32 port patterns)
        var priorityPatterns = new[] 
        { 
            "ttyACM",    // Linux - STM32 USB CDC
            "ttyUSB",    // Linux - USB-Serial adapter
            "cu.usb",    // macOS - USB devices
            "COM"        // Windows - COM ports
        };

        // Sort ports by priority
        var sortedPorts = availablePorts
            .OrderBy(p => 
            {
                for (int i = 0; i < priorityPatterns.Length; i++)
                {
                    if (p.Contains(priorityPatterns[i]))
                        return i;
                }
                return priorityPatterns.Length;
            })
            .ToList();

        // Try each port
        foreach (var port in sortedPorts)
        {
            _logger.LogInformation($"‚ö° Probing {port}...");
            
            if (await ProbePortAsync(port, baudRate))
            {
                _logger.LogInformation($"‚úì STM32 detected on {port}");
                return port;
            }
        }

        return string.Empty;
    }

    /// <summary>
    /// Probe a specific port to check if STM32 is connected
    /// </summary>
    private async Task<bool> ProbePortAsync(string portName, int baudRate)
    {
        SerialPort? testPort = null;
        
        try
        {
            testPort = new SerialPort(portName, baudRate)
            {
                Parity = Parity.None,
                StopBits = StopBits.One,
                DataBits = 8,
                Handshake = Handshake.None,
                ReadTimeout = 1000,
                WriteTimeout = 1000
            };

            testPort.Open();
            await Task.Delay(100); // Wait for port to stabilize

            // Send a ping command to check if STM32 responds
            var pingCommand = new STM32BrewCommand
            {
                CommandType = "PING",
                Parameters = new BrewParameters()
            };

            var jsonOptions = new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
            };
            var jsonCommand = JsonSerializer.Serialize(pingCommand, jsonOptions);
            
            testPort.WriteLine(jsonCommand);

            // Try to read response
            try
            {
                var response = await Task.Run(() => testPort.ReadLine());
                
                // Check if response looks like valid JSON from STM32
                if (response.Contains("success") || response.Contains("status") || response.Contains("STM32"))
                {
                    return true;
                }
            }
            catch (TimeoutException)
            {
                // No response, not an STM32
                return false;
            }

            return false;
        }
        catch (UnauthorizedAccessException)
        {
            _logger.LogDebug($"   {portName} is in use by another application");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogDebug($"   {portName} probe failed: {ex.Message}");
            return false;
        }
        finally
        {
            if (testPort?.IsOpen == true)
            {
                testPort.Close();
            }
            testPort?.Dispose();
        }
    }

    /// <summary>
    /// Get list of all available serial ports
    /// </summary>
    public string[] GetAvailablePorts()
    {
        return SerialPort.GetPortNames();
    }

    public async Task DisconnectAsync()
    {
        if (_serialPort?.IsOpen == true)
        {
            _serialPort.Close();
            _logger.LogInformation("Disconnected from STM32");
        }
        await Task.CompletedTask;
    }

    public async Task<STM32Response> SendCommandAsync(STM32BrewCommand command)
    {
        if (!IsConnected)
        {
            _logger.LogWarning("‚ö†Ô∏è  Not connected to STM32 - simulating response");
            // Simulate response for testing without hardware
            return new STM32Response 
            { 
                Success = true, 
                Status = "SIMULATED", 
                Message = "Command received (simulated - no STM32 connected)" 
            };
        }

        try
        {
            // Serialize command to JSON
            var jsonOptions = new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
            };
            var jsonCommand = JsonSerializer.Serialize(command, jsonOptions);
            
            _logger.LogInformation($"‚Üí Sending to STM32: {jsonCommand}");
            
            // Send command with newline terminator
            _serialPort!.WriteLine(jsonCommand);

            // Wait for response
            var responseJson = await Task.Run(() => _serialPort.ReadLine());
            
            _logger.LogInformation($"‚Üê Received from STM32: {responseJson}");

            // Deserialize response
            var response = JsonSerializer.Deserialize<STM32Response>(responseJson, jsonOptions);
            return response ?? new STM32Response { Success = false, Message = "Invalid response" };
        }
        catch (TimeoutException)
        {
            _logger.LogError("Timeout waiting for STM32 response");
            return new STM32Response { Success = false, Status = "TIMEOUT", Message = "STM32 did not respond" };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error communicating with STM32");
            return new STM32Response { Success = false, Status = "ERROR", Message = ex.Message };
        }
    }

    public async Task<STM32Response> GetStatusAsync()
    {
        var command = new STM32BrewCommand
        {
            CommandType = "STATUS",
            Parameters = new BrewParameters()
        };

        return await SendCommandAsync(command);
    }
}
